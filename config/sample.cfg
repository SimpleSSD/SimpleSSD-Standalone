#
# Copyright (C) 2017 CAMELab
#
# This file is part of SimpleSSD.
#
# SimpleSSD is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# SimpleSSD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with SimpleSSD.  If not, see <http://www.gnu.org/licenses/>.
#

#
# Sample SimpleSSD-Standalone Configuration File
#
# Section:
# global:    Global options
# generator: Request generator configuration
# trace:     Trace replayer configuration
#

# Global Configuration
[global]

## Select mode
# Possible values:
#  0: Request generator mode (all configs in [trace] will be ignored)
#  1: Trace replayer mode (all configs in [generator] will be ignored)
Mode = 0

## Statistic log period
# Print statistic log periodically
# 0 means no log printout
# Unit: ms (millisecond) in simulation time (not real time)
LogPeriod = 10

## Log file
# Set output path of statistic log and debug log
# <empty value> means no log printout
# Possible keywords:
#  STDOUT: Standard Output
#  STDERR: Standard Error
LogFile = STDOUT
DebugLogFile = STDERR

## Interface
# Set host interface to use
# Possible values:
#  0: No interface - directly send request to HIL layer
#  1: NVMe - Use Non-Volatile Memory Express
#  2: SATA - Use Serial AT Attachment
#  3: UFS - Use Universal Flash Storage
Interface = 0

## Scheduler
# Set scheduler to use in Block I/O Layer
# Possible values:
#  0: Noop - No scheduling
Scheduler = 0

# Request generator configuration
[generator]

## This request generator will work similar to Flexible I/O tester
# Definition of Types:
#  str:  String, a sequence of alphanumeric characters
#  int:  SI integer, a sequence of numeric characters
#        Possible suffix (case sensitive):
#         10^3 base: k, m, g, t
#         2^10 base: K, M, G, T
#  bool: Boolean, a true or false value.
#        Possible value (case insensitive):
#         True: Non-zero number, T, True, Y, Yes
#         False: Otherwise
#  time: SI integer, a sequenced of numeric characters
#        If no suffix provided, value will treated as pico-second.
#        Possible suffix (case sensitive):
#         s, ms, us, ns, ps

## Total size to I/O = int
io_size = 16M   # 16 * 2^20 bytes

## Type of I/O = str
# Possible values:
#  read:      Sequential read
#  write:     Sequential write
#  randread:  Random read
#  randwrite: Random write
#  readwrite: Mixed sequential I/O
#  randrw:    Mixed random I/O
readwrite = read

## Percentage of mixed I/O = int
# If readwrite is not readwrite nor randrw, this value will ignored
rwmixread = 50   # 50% of read I/O

## Block size = int
blocksize = 4K

## Block align = int
# Default <empty value> is blocksize
blockalign =

## I/O mode = str
# Possible values:
#  sync:  Synchronous I/O
#  async: Asynchronous I/O
iomode = async

## I/O depth = int
iodepth = 32

## Offset = int
offset = 0

## Size = int
# Default <empty value> is [SSD size] - <offset>
size =

## Thinktime = time
thinktime = 0

## Random seed = int
randseed = 13245

## Time based = bool
time_based = 0

## Runtime = time
# Only valid when time_based = true
runtime = 10

## Ramp time = time
# Only valid when time_based = true
ramp_time = 5

# Trace replayer configuration
[trace]

## Trace file
File = ./test.txt

## Trace file regular expression
# See C++11 Regular Expression Library
# Always use ECMAScript regular expression grammar
# Unmatched line will be ignored
Regex = "\d+,\d+ +\d+ +\d+ +(\d+).(\d+) +\d+ +D +\w+ +(\d+) \+ (\d+)"

## Trace file group ID
# Mapping field and group ID of parsed trace file
# <Field> = <Group ID>
# Field may empty
# All time field will be added up
# Group ID 0 is matched string (Do not use)
# All field should contain integer (not floating point number)
ByteOffset =
ByteLength =
LBAOffset = 3
LBALength = 4
Second = 1
Millisecond =
Microsecond =
Nanosecond = 2
Picosecond =

## LBA size
# Set LBA size if LBA offset/length used
LBASize = 512

## Treat field as hexadecimal
# Double check that the regular expression captures hexadecimal number
UseHexadecimal = 0
